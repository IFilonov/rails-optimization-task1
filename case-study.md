# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше 30 мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы 
я придумал использовать такую метрику:

Метрика:

    время полной обработки в секундах

Бюджет:

    30 секунд

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *время, которое у вас получилось*

Вот как я построил `feedback_loop`: 

1  Построить ассимптотику 1000/10_000-100_000 шаг 10000

2  Прикинуть зависимость времени работы програмы от размера обрабатываемого файла

3  Установить рубокоп_перфоманс. Сделать новую ассимптотику

3  Построить и проанализировать отчёт `ruby-prof` в режиме `Flat`;

4  Построить и проанализировать отчёт `ruby-prof` в режиме `Graph`;

5  Построить и проанализировать отчёт `ruby-prof` в режиме `CallStack`;

6  Построить и проанализировать отчёт `ruby-prof` в режиме `CallTree` c визуализацией в `QCachegrind`;

7  Построить дамп `stackprof` и проанализировать его с помощью `CLI`

8  Построить дамп `stackprof` в `json` и проанализировать его с помощью `speedscope.app`

9  Профилировать работающий процесс `rbspy`;

10 Добавить в программу `ProgressBar`;

11 Постараться довести асимптотику до линейной и проверить это тестом;

12 Написать простой тест на время работы: когда вы придёте к оптимизированному решению, замерьте, сколько оно будет работать на тестовом объёме данных; и напишите тест на то, что это время не превышается (чтобы не было ложных срабатываний, задайте время с небольшим запасом);

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- построил ассимптотику, код запуска:
  
      ruby assimptotics.rb
  
  Assimptotics results:
  
  1000: 0 sec;
  
  10000: 1 sec;
  
  20000: 6 sec;
  
  30000: 14 sec;
  
  40000: 30 sec;
  
  50000: 52 sec;
  
  60000: 75 sec;
  
  70000: 102 sec;
  
  80000: 133 sec;
  
  90000: 177 sec;
  
  100000: 225 sec;
  
  Зависимость нелинейная, похожа на квадратичную. Используя квадратичное уравнение по двум точкам 50000 и 100000
  получилось завершение программы на моем оборудовании за 371297 сек = 103 часа.

### Ваша находка №2
- обработал rubocop-performance, тест проходит:
  
      rubocop task-1.rb -A
  1 file inspected, 118 offenses detected, 82 offenses corrected

  изменения по большей части синткасические сахарные, ушли лишние сложения строк и переменных, поэтому время работы сократилось только на 10%.
  Оставил три точки измерения:

  30000: 12 sec;
  
  50000: 45 sec;

  100000: 197 sec;


### Ваша находка №3
- запустил rbspy  (скрипт запуска и результат в /1-rbspy/).
  В выходном файле (верхняя часть) получил 

      % self  % total  name
      83.30    83.30  block (2 levels) in work - /home/filonov/optim/rails-optimization-task1/task-1.rb:105
      14.06    97.27  select [c function] - (unknown):0
  
- 83% времени занимает работа блока (второго уровня) в 105 строке. 
  Т.к. на каждого пользователя каждый раз запускается фильтр по всем сессиям 
  решил подготовить сессии пользователей заранее, получив один проход по сессиям.
- значение метрики сократилась в ~20 раз. Добавил новое значение для метрики - 500_000

  30000: 0 sec;
  
  50000: 2 sec;
  
  100000: 5 sec;

  500000: 175 sec;


- Отчет профилировщика изменился:

      % self  % total  name
      92.47    93.43  block in work - /home/filonov/optim/rails-optimization-task1/task-1.rb:57
      2.52     2.54  block in work - /home/filonov/optim/rails-optimization-task1/task-1.rb:112

### Ваша находка №4
- запустил RubyProf  (скрипт запуска и результат в /2-ruby-prof-flat/).
  В выходном файле (верхняя часть) получил

      %self      total      self      wait     child     calls  name                           location
      92.81    216.061   201.285     0.000    14.777       11   Array#each                     
      2.70      5.884     5.859     0.000     0.024   500000   Array#all?                     
      1.05      2.281     2.281     0.000     0.000  1000001   String#split

- 92% времени занимает работа блока each, который встречается 5 раз. Rbspy лучше, т.к. указывает строку.
  С учетом данных rbspy оптимизирую первый each: 
    
  a) Массив пользователей и сессий создается через +, что заставляет память выделять место под новый массив.
  Метод << или push использует тот же массив. Главная причина.
  
  б) Split строки на массив происходит три раза. Убираю.
  
  в) if заменяю на case, чтобы в случае строки с пользователем, анализ на сессию уже не производился.
  
- значение метрики сократилась в ~10 раз. Добавил новое значение для метрики - 1000_000

  50000: 1 sec;
  
  100000: 1 sec;
  
  500000: 13 sec;

  1000000: 41 sec;

- Отчет профилировщика изменился:

      %self      total      self      wait     child     calls  name                           location
      37.03      0.000     0.000     0.000     0.000        1   <Class::IO>#read               
      30.11      0.000     0.000     0.000     0.000        1   [global]#                      ruby-prof-flat.rb:10

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*

